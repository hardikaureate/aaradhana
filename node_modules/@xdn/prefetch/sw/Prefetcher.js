"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var workbox_routing_1 = require("workbox-routing");
var workbox_strategies_1 = require("workbox-strategies");
var workbox_expiration_1 = require("workbox-expiration");
var workbox_cacheable_response_1 = require("workbox-cacheable-response");
var constants_1 = require("../constants");
var log_1 = __importDefault(require("./log"));
var PrefetchPlugin_1 = __importDefault(require("./PrefetchPlugin"));
var DevtoolsPlugin_1 = __importDefault(require("./DevtoolsPlugin"));
var messageBrowser_1 = __importDefault(require("./messageBrowser"));
var CustomCacheKeyPlugin_1 = __importDefault(require("./CustomCacheKeyPlugin"));
var ChangeMethodPlugin_1 = __importDefault(require("./ChangeMethodPlugin"));
var Stats = /** @class */ (function () {
    function Stats() {
        this.hits = 0;
        this.misses = 0;
    }
    return Stats;
}());
exports.Stats = Stats;
var BUFFER_DELAY_MS = 10000;
/**
 * Handles prefetching and caching in the the service worker.  Responses
 * are cached based on the `browser.serviceWorkerSeconds` cache setting in your routes.
 *
 * **Example routes.js**
 *
 * ```js
 *  import { Router } from '@xdn/core/router'
 *
 *  module.exports = new Router()
 *    .match('/some/path', ({ cache }) => {
 *      cache({
 *        edge: {
 *          maxAgeSeconds: 60 * 60 * 24 // one day
 *        },
 *        browser: {
 *          serviceWorkerSeconds: 60 * 60 // one hour
 *        }
 *      })
 *    })
 * ```
 *
 * **Example Service Worker**
 *
 * ```js
 *  import { skipWaiting, clientsClaim } from 'workbox-core'
 *  import { Prefetcher } from '@xdn/prefetch/sw'
 *  import { precacheAndRoute } from 'workbox-precaching'
 *
 *  skipWaiting()
 *  clientsClaim()
 *  precacheAndRoute(self.__WB_MANIFEST || [])
 *
 *  new Prefetcher().route()
 * ```
 */
var Prefetcher = /** @class */ (function () {
    function Prefetcher(config) {
        if (config === void 0) { config = { plugins: [] }; }
        // For performance reasons, Devtools plugins are disabled until the first
        // 'xdn-devtools-syn' message is received (ie: a Devtools client is enabled).
        // But once enabled, they will remain active until the Service Worker is reinstalled
        this.devtoolsEnabled = false;
        /**
         * bufferedDevtoolMessages keeps track of the request received in the last BUFFER_DELAY_MS.
         */
        this.bufferedDevtoolMessages = [];
        this.config = config;
        var manifestURL = '__xdn__/cache-manifest.js';
        this.cacheOrigins = [self.origin];
        if (config.cacheHost) {
            this.cacheHost = new URL("https://" + config.cacheHost);
            this.cacheOrigins.push(this.cacheHost.origin);
            manifestURL = this.cacheHost.toString() + manifestURL;
        }
        importScripts(manifestURL);
        this.cacheableResponsePlugin = new workbox_cacheable_response_1.CacheableResponsePlugin({
            statuses: [200, 301, 302],
        });
        this.stats = new Stats();
        this.initStats();
        this.initDevtoolsHandshakeListener();
    }
    Prefetcher.prototype.getRouteConfigsFromManifest = function () {
        // @ts-ignore
        var manifest = self.__XDN_CACHE_MANIFEST__;
        return manifest.map(function (_a) {
            var criteriaPath = _a.criteriaPath, route = _a.route, cacheOptions = _a.cacheOptions, method = _a.method, returnsResponse = _a.returnsResponse;
            var _b, _c, _d;
            var maxAgeSeconds = (_b = cacheOptions.browser) === null || _b === void 0 ? void 0 : _b.serviceWorkerSeconds;
            var edgeMaxAgeSeconds = (_c = cacheOptions.edge) === null || _c === void 0 ? void 0 : _c.maxAgeSeconds;
            return {
                criteriaPath: criteriaPath,
                pattern: route,
                method: method,
                maxAgeSeconds: maxAgeSeconds,
                edgeMaxAgeSeconds: edgeMaxAgeSeconds,
                returnsResponse: returnsResponse,
                isPartialPathRoute: true,
                key: cacheOptions.key,
                convertToGet: (_d = cacheOptions.browser) === null || _d === void 0 ? void 0 : _d.convertToGet,
                prefetchUpstreamRequests: cacheOptions.prefetchUpstreamRequests,
            };
        });
    };
    Prefetcher.prototype.registerDevtoolsRoutes = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.getRouteConfigsFromManifest()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var routeConfig = _c.value;
                // Add listener for all routes that are not cached in the browser as those already have a route handler
                if (!routeConfig.maxAgeSeconds && !routeConfig.returnsResponse) {
                    this.createDevtoolsRoute(routeConfig);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Also add a fallback route in case the cache manifest does not specify any
        this.createDevtoolsRoute();
    };
    /**
     * Adds a fetch event listener that serves content from the browser cache when available.  When
     * a request is not in the cache, it will be fetched from the network and added to the
     * cache if the route has `browser.serviceWorkerSeconds` defined in its `cache` setting.
     */
    Prefetcher.prototype.route = function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.getRouteConfigsFromManifest()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var routeConfig = _c.value;
                if (
                // Only listen for browser cached routes:
                (routeConfig.maxAgeSeconds && routeConfig.maxAgeSeconds > 0) ||
                    // or for routes that return an x-xdn-upstream-requests header:
                    routeConfig.prefetchUpstreamRequests) {
                    this.createRoute(routeConfig);
                }
                else if (routeConfig.returnsResponse) {
                    // register routes that return responses to force a network call and prevent
                    // a later route from matching and caching non-cacheable routes:
                    workbox_routing_1.registerRoute(this.shouldIntercept(new RegExp(routeConfig.pattern, 'i'), routeConfig.isPartialPathRoute), new workbox_strategies_1.NetworkOnly({
                        plugins: [this.createDevtoolsPlugin(routeConfig)],
                    }));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this;
    };
    Prefetcher.prototype.cache = function (pattern, maxAgeSeconds) {
        if (maxAgeSeconds === void 0) { maxAgeSeconds = 60 * 60 * 24; }
        this.createRoute({ pattern: pattern.source, maxAgeSeconds: maxAgeSeconds, isPartialPathRoute: false });
        return this;
    };
    /**
     * Starts listening for messages from the browser
     */
    Prefetcher.prototype.initStats = function () {
        var _this = this;
        self.addEventListener('message', function (e) {
            if (e.data.action === 'get-stats') {
                messageBrowser_1.default({
                    type: 'stats',
                    stats: _this.stats,
                });
            }
        });
    };
    /**
     * Here we implement a handshake protocol between the devtool window client and the service worker:
     * 1. Devtools sends the 'xdn-devtools-syn' event and starts listening for 'xdn-devtools-ack' event
     * 2. Service worker receives the 'xdn-devtools-syn' event and sends the 'xdn-devtools-ack' event
     *    along with the buffered messages that were received over the last BUFFER_DELAY_MS.
     *    This is because the window widget takes time to download, load and to start listening from
     *    Service worker message, while the latter is already receiving http requests.
     * 3. Devtools receives the 'xdn-devtools-ack' event, looks for its current page html request,
     *    which corresponds to that tab very first request, and loads requests past that one.
     * 4. Devtools starts listening for live 'xdn-devtools-request' events
     *
     * Notes:
     * - there is no 1-1 channel between window client and Service Worker, so all opened tab
     *   will see the 'xdn-devtools-ack' event. Only the ones in handshake phase will handle it.
     */
    Prefetcher.prototype.initDevtoolsHandshakeListener = function () {
        var _this = this;
        self.addEventListener('message', function (e) { return __awaiter(_this, void 0, void 0, function () {
            var ackMessage;
            return __generator(this, function (_a) {
                if (e.data.action === 'xdn-devtools-install') {
                    if (!this.devtoolsEnabled) {
                        this.registerDevtoolsRoutes();
                        this.devtoolsEnabled = true;
                        // Devtools plugin just got initialized so we missed
                        // a few queries. We send a message so that the browser
                        // refreshes its page.
                        this.sendToAllClients({
                            type: 'xdn-devtools-ack-installed',
                        });
                    }
                }
                if (e.data.action === 'xdn-devtools-syn') {
                    if (this.devtoolsEnabled) {
                        ackMessage = {
                            type: 'xdn-devtools-ack',
                            bufferedDevtoolMessages: this.bufferedDevtoolMessages,
                        };
                        this.sendToAllClients(ackMessage);
                    }
                }
                if (e.data.action === 'xdn-devtools-clear-cache') {
                    caches.keys().then(function (cacheNames) { return cacheNames.forEach(function (name) { return caches.delete(name); }); });
                }
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Send a postMessage event to all window client.
     * Notes:
     * - When used in multi-tabs, each Devtools will show data from all tabs.
     *   That's a bit buggy but it's the best we can do as it's very hard to establish 1-1 channels
     *   on ServiceWorker/Client interface, for example the message event from the window does not
     *   contain the clientId
     */
    Prefetcher.prototype.sendToAllClients = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                messageBrowser_1.default(data, { broadcast: true });
                return [2 /*return*/];
            });
        });
    };
    /**
     * Adds a message to this.bufferedDevtoolMessages and manages the buffer so that
     * we don't keep messages more than BUFFER_DELAY_MS.
     *
     * In case of inactivity we clear the whole buffer after BUFFER_DELAY_MS, so technically
     * a message can stay up to 2 x BUFFER_DELAY_MS in the buffer (a bit less than BUFFER_DELAY_MS old
     * when the latest message arrives and cleared BUFFER_DELAY_MS later)
     * @param message
     */
    Prefetcher.prototype.addDevtoolsRequestMessageToBuffer = function (message) {
        var _this = this;
        this.bufferedDevtoolMessages.push(message);
        this.trimDevtoolsRequestMessageBuffer();
        if (this.clearDevtoolsRequestMessageTimeout) {
            clearTimeout(this.clearDevtoolsRequestMessageTimeout);
        }
        // If no additional request for BUFFER_DELAY_MS, we clear the buffer after that
        this.clearDevtoolsRequestMessageTimeout = setTimeout(function () {
            _this.bufferedDevtoolMessages = [];
        }, BUFFER_DELAY_MS);
    };
    /**
     * Remove message that are too old to stay in devtools message buffer
     */
    Prefetcher.prototype.trimDevtoolsRequestMessageBuffer = function () {
        var sliceIndex = 0;
        var sliceMinimumTimestamp = Date.now() - BUFFER_DELAY_MS;
        while (this.bufferedDevtoolMessages[sliceIndex] &&
            this.bufferedDevtoolMessages[sliceIndex].timestamp < sliceMinimumTimestamp) {
            sliceIndex++;
        }
        this.bufferedDevtoolMessages = this.bufferedDevtoolMessages.slice(sliceIndex);
    };
    /**
     * If there's a cacheHost configured check whether the pattern to test
     * against is a partial pathname pattern. If so, check that the origin is
     * also correct: service worker's own origin or cacheHost origin
     * @param pattern A route pattern
     * @param isPartialPathRoute Set to true if the supplied pattern only matches the path, false if it matches the whole URL.
     * @param options.skipAssets Set to true to ignore request that are not 'document' or 'empty' (ie: audio, font, image, ...)
     * @return true if the request should be handled by the service worker.
     */
    Prefetcher.prototype.shouldIntercept = function (pattern, isPartialPathRoute, _a) {
        var _this = this;
        var _b = (_a === void 0 ? {} : _a).skipAssets, skipAssets = _b === void 0 ? false : _b;
        return function (_a) {
            var url = _a.url, request = _a.request;
            if (skipAssets && !['document', 'empty'].includes(request.destination))
                return false;
            if (isPartialPathRoute) {
                return _this.cacheOrigins.includes(url.origin) && pattern.test(url.pathname);
            }
            else {
                return pattern.test(url.toString());
            }
        };
    };
    /**
     * Creates a DevtoolsPlugin object to be added to a caching strategy instance
     * @param routeConfig The route config for the given route
     * @private
     */
    Prefetcher.prototype.createDevtoolsPlugin = function (routeConfig) {
        var _this = this;
        return new DevtoolsPlugin_1.default({
            onResponse: this.onResponse.bind(this),
            isEnabledFn: function () { return _this.devtoolsEnabled; },
            routeConfig: routeConfig,
        });
    };
    /**
     * Creates a Workbox route which only purpose is to forward requests/response
     * data to the Devtools
     * @param routeConfig The route pattern and caching options specified within the route definition
     *                    If undefined, it catches all GET queries except static assets
     */
    Prefetcher.prototype.createDevtoolsRoute = function (routeConfig) {
        var method, routeMatcher;
        if (routeConfig) {
            var pattern = routeConfig.pattern, isPartialPathRoute = routeConfig.isPartialPathRoute;
            var patternRegexp = new RegExp(pattern, 'i');
            routeMatcher = this.shouldIntercept(patternRegexp, isPartialPathRoute, { skipAssets: true });
            method = (routeConfig.method || 'get').toUpperCase();
        }
        else {
            routeMatcher = this.shouldIntercept(/^.*$/, true, { skipAssets: true });
            method = 'GET';
        }
        workbox_routing_1.registerRoute(routeMatcher, new workbox_strategies_1.NetworkOnly({
            plugins: [this.createDevtoolsPlugin(routeConfig)],
        }), 
        // @ts-ignore
        method);
    };
    /**
     * Creates a workbox route.
     * @param routeConfig The route pattern and caching options specified within the route definition
     */
    Prefetcher.prototype.createRoute = function (routeConfig) {
        var pattern = routeConfig.pattern, optMethod = routeConfig.method, maxAgeSeconds = routeConfig.maxAgeSeconds, isPartialPathRoute = routeConfig.isPartialPathRoute, key = routeConfig.key, convertToGet = routeConfig.convertToGet;
        var method = (optMethod || 'get').toLowerCase();
        log_1.default("[route] " + method + " " + pattern + ", maxAgeSeconds: " + maxAgeSeconds);
        var patternRegexp = new RegExp(pattern, 'i');
        // all routes must have a GET route registered, so Workbox can properly look
        // it up when running workbox-routing/Router#findMatchingRoute:
        if (method !== 'get') {
            this.createRoute(__assign(__assign({}, routeConfig), { method: 'get' }));
        }
        var prefetchPlugin = new PrefetchPlugin_1.default({
            incrementRead: this.incrementRead.bind(this),
            incrementWrite: this.incrementWrite.bind(this),
            cacheHost: this.cacheHost,
            prefetchUpstreamRequests: routeConfig.prefetchUpstreamRequests,
        });
        var plugins = __spread([
            this.cacheableResponsePlugin,
            new workbox_expiration_1.ExpirationPlugin({
                maxAgeSeconds: maxAgeSeconds,
            }),
            // DevtoolPlugin needs to be injected before PrefetchPlugin as this later
            // changes request url to normalise the cache key
            this.createDevtoolsPlugin(routeConfig),
            prefetchPlugin
        ], (this.config.plugins || []));
        if (key) {
            plugins.push(new CustomCacheKeyPlugin_1.default(patternRegexp, key));
        }
        if (convertToGet) {
            // ChangeMethodPlugin must come before PrefetchPlugin so body is retained:
            plugins.splice(plugins.indexOf(prefetchPlugin), 0, new ChangeMethodPlugin_1.default([patternRegexp]));
        }
        workbox_routing_1.registerRoute(this.shouldIntercept(patternRegexp, isPartialPathRoute), new workbox_strategies_1.CacheFirst({
            cacheName: constants_1.CACHE_NAME,
            matchOptions: {
                ignoreVary: true,
            },
            plugins: plugins,
        }), 
        // @ts-ignore
        method.toUpperCase() // HTTPMethods map directly from @xdn/core lowercase => @workbox uppercase
        );
    };
    /**
     * A Read is considered a Hit until a Write happens meaning it was a miss
     * This is based on the fragile assumption that a cache read *always* triggers a write
     * in case of cache miss, which is not true if the backend does not respond for example.
     *
     * This could be fixed by checking the presence of `response` in `cachedResponseWillBeUsed``
     * but that leads to other issues as we cannot discard Prefetch requests at that
     * stage.
     * We could implement the same Hack-ish solution as in DevtoolsPlugin to work around that,
     * but those simple stats are probably going away anyway.
     */
    Prefetcher.prototype.incrementRead = function () {
        this.stats.hits++;
    };
    Prefetcher.prototype.incrementWrite = function () {
        this.stats.misses++;
        this.stats.hits--;
    };
    Prefetcher.prototype.onResponse = function (_a) {
        var request = _a.request, response = _a.response, ttfb = _a.ttfb, prefetch = _a.prefetch, browserCache = _a.browserCache, routeConfig = _a.routeConfig;
        return __awaiter(this, void 0, void 0, function () {
            var headers, devToolMessage;
            return __generator(this, function (_b) {
                headers = {};
                response.headers.forEach(function (value, key) {
                    headers[key] = value;
                });
                devToolMessage = {
                    type: 'xdn-devtools-request',
                    timestamp: Date.now(),
                    request: {
                        method: request.method,
                        url: request.url,
                        prefetch: prefetch,
                    },
                    response: {
                        ttfb: ttfb,
                        status: response.status,
                        headers: headers,
                    },
                    browserCache: browserCache,
                    routeConfig: routeConfig,
                };
                this.sendToAllClients(devToolMessage);
                this.addDevtoolsRequestMessageToBuffer(devToolMessage);
                return [2 /*return*/];
            });
        });
    };
    return Prefetcher;
}());
exports.default = Prefetcher;
