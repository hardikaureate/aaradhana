"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var convertParamsToBackReferences_1 = __importStar(require("../utils/convertParamsToBackReferences"));
var validateBackends_1 = __importDefault(require("../utils/validateBackends"));
var constants_1 = require("../constants");
var Route_1 = __importDefault(require("../router/Route"));
var ResponseWriter_1 = __importDefault(require("../router/ResponseWriter"));
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var some_1 = __importDefault(require("lodash/some"));
var get_1 = __importDefault(require("lodash/get"));
var validateWriter_1 = require("../router/validateWriter");
var universalRouteUtils_1 = require("../router/universalRouteUtils");
var FAR_FUTURE_TTL = 60 * 60 * 24 * 365 * 10;
/**
 * A substitute implementation of `ResponseWriter` that creates the contents of `xdn.json`, which
 * is used to generate edge code.
 */
var EdgeResponseWriter = /** @class */ (function (_super) {
    __extends(EdgeResponseWriter, _super);
    /**
     * @param req The `HttpRequest` object
     * @param res The `HttpResponse` object
     * @param route The route being hit
     * @param context The request context
     */
    function EdgeResponseWriter(_req, _res, route, context) {
        var _this = _super.call(this, _req, _res, route, context) // istanbul ignore next - this is a known issue with TypeScript
         || this;
        // Many of the methods such as updateRequestHeader assume transform.request
        // and transform.response are initialized to empty arrays by the constructor.
        _this.stream = function () { };
        _this.setRequestHeader = function (name, value) {
            validateWriter_1.validateSetRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateRequestHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeRequestHeader = function (name) {
            validateWriter_1.validateRemoveRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.setResponseHeader = function (name, value) {
            validateWriter_1.validateSetResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateResponseHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeResponseHeader = function (name) {
            validateWriter_1.validateRemoveResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.setUpstreamResponseHeader = function (name, value) {
            validateWriter_1.validateSetResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateUpstreamResponseHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeUpstreamResponseHeader = function (name) {
            validateWriter_1.validateRemoveResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.addResponseCookie = function (name, value) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.addCookie,
                name: name,
                value: value,
            });
        };
        _this.updateResponseCookie = function (name, match, replace) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateCookie,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeResponseCookie = function (name) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeCookie,
                name: name,
            });
        };
        _this.addUpstreamResponseCookie = function (name, value) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.addCookie,
                name: name,
                value: value,
            });
        };
        _this.updateUpstreamResponseCookie = function (name, match, replace) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateCookie,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeUpstreamResponseCookie = function (name) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeCookie,
                name: name,
            });
        };
        /**
         * Sends a redirect from the edge
         *
         * In case of a complex redirect where the router needs to parse query string
         * from the matched request, or inject query strings in the redirect, we delegate
         * the response to Serverless compute and cache it for a very long time.
         *
         *
         * @param to The destination URL
         * @param statusCode The http response status.
         */
        _this.redirect = function (to, options) {
            if (options === void 0) { options = {}; }
            var _a = _this._readRedirectParams(to, options), toPath = _a.to, statusCode = _a.statusCode, query = _a.query;
            var addQueryString = !isEmpty_1.default(query);
            var writerParam = convertParamsToBackReferences_1.getBackReferences(Route_1.default.pathWithQueryString(toPath, query));
            // @ts-ignore - lodash.some type seem broken for 2 args callback
            var parseQueryString = some_1.default(_this.route.criteria.query, function (value, key) { return universalRouteUtils_1.isParamMatcher(value) && writerParam[key]; });
            // Complex redirects manipulating query string are delegated to compute and cached "for ever".
            // Cache key includes query string by default so every path / query string
            // combination is cached independently, which is what we want as redirects
            // location header includes original request's query string
            if (parseQueryString || addQueryString) {
                _this.cache({
                    edge: {
                        maxAgeSeconds: FAR_FUTURE_TTL,
                    },
                });
                _this.proxy(constants_1.BACKENDS.js);
                return;
            }
            _this.setEdgeRoute({ action: constants_1.ACTIONS.syntheticRes, statusCode: statusCode });
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name: constants_1.HTTP_HEADERS.location,
                value: '${url}',
            });
            if (_this.route.criteria.path) {
                // This applies the 'to' argument, interpolate path params from the original request
                // and appends original request's query strings (hence the added path-to-regexp matcher and added
                // back reference)
                var valueRegex = Route_1.default.toEdgeRegexString(_this.route.criteria.path + '{(\\?[^#]+)}?');
                var matchParams = convertParamsToBackReferences_1.getBackReferences(_this.route.criteria.path);
                var replaceValue = convertParamsToBackReferences_1.default(_this.route.criteria.path, toPath) +
                    ("\\" + (Object.keys(matchParams).length + 1));
                _this.edgeConfig.transform.response.push({
                    action: constants_1.ACTIONS.updateHeader,
                    name: constants_1.HTTP_HEADERS.location,
                    valueRegex: valueRegex,
                    replaceValue: replaceValue,
                });
            }
            else {
                // This is a very special case where there is no path matcher, which is generally
                // the case for fallback routes.
                // We only extract the query string from the request path and
                // apply them to the redirect 'to'.
                _this.edgeConfig.transform.response.push({
                    action: constants_1.ACTIONS.updateHeader,
                    name: constants_1.HTTP_HEADERS.location,
                    valueRegex: Route_1.default.toEdgeRegexString('([^?]*){(\\?[^#]+)}?'),
                    replaceValue: toPath + "\\2",
                });
            }
        };
        /**
         * Serves static assets.
         * @param path The request path
         */
        _this.serveStatic = function (path, _a) {
            var _b = _a === void 0 ? {} : _a, permanent = _b.permanent, exclude = _b.exclude, onNotFound = _b.onNotFound, loadingPage = _b.loadingPage, expiresSeconds = _b.expiresSeconds;
            if (path && !path.startsWith('/'))
                path = "/" + path;
            var fsPath = [];
            var loadingPageTransform;
            if (loadingPage) {
                fsPath.push(loadingPage);
                loadingPageTransform = {
                    valueRegex: _this.route.toEdgeRegexString(),
                    replaceValue: convertParamsToBackReferences_1.default(_this.route.criteria.path, loadingPage),
                };
            }
            if (path) {
                _this.updatePath(path);
            }
            if (typeof path === 'string') {
                fsPath.push(path);
            }
            var isPermanent = permanent === true || get_1.default(permanent, 'enabled') || false;
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: isPermanent ? constants_1.BACKENDS.permanentStatic : constants_1.BACKENDS.static,
                fsPath: fsPath,
                fsExclude: exclude,
                fallbackToCompute: onNotFound != null,
                loadingPage: loadingPageTransform,
                expiresSeconds: expiresSeconds,
            });
            return Promise.resolve();
        };
        /**
         * Proxies from the edge
         * @param backend
         * @param config
         * @param config.path
         */
        _this.proxy = function (backend, _a) {
            var _b = _a === void 0 ? {} : _a, path = _b.path, transformResponse = _b.transformResponse, transformRequest = _b.transformRequest;
            validateBackends_1.default(backend);
            if (transformResponse != null || transformRequest != null || typeof path === 'function') {
                backend = constants_1.BACKENDS.js;
            }
            else if (typeof path === 'string') {
                // Only rewrite the request path if we're not going through compute, otherwise the router
                // in compute would match the wrong route
                _this.updatePath(path);
            }
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: backend,
            });
            return Promise.resolve();
        };
        /**
         * Rewrites the request path.
         */
        _this.updatePath = function (destination) {
            var replacePathValue = convertParamsToBackReferences_1.default(_this.route.criteria.path, destination);
            // Makes path definition more flexible, allowing path with no / prefix (ex: { path: ':path' })
            if (replacePathValue[0] !== '/') {
                replacePathValue = "/" + replacePathValue;
            }
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updatePath,
                valueRegex: _this.route.toEdgeRegexString(),
                replaceValue: replacePathValue,
            });
        };
        /**
         * Creates the edge cache config
         * @param config
         */
        _this.cache = function (config) {
            var edge = config.edge, browser = config.browser, key = config.key;
            if (edge) {
                var maxAgeSeconds = edge.maxAgeSeconds, staleWhileRevalidateSeconds = edge.staleWhileRevalidateSeconds, forcePrivateCaching = edge.forcePrivateCaching;
                _this.edgeConfig.cache = {
                    maxAgeSeconds: maxAgeSeconds,
                    staleWhileRevalidateSeconds: staleWhileRevalidateSeconds,
                    forcePrivateCaching: forcePrivateCaching,
                };
            }
            else if (edge === false) {
                _this.edgeConfig.cache = {
                    disabled: true,
                };
            }
            if (key) {
                if (!_this.edgeConfig.cache) {
                    _this.edgeConfig.cache = {};
                }
                _this.edgeConfig.cache.customKey = key.toJSON();
            }
            if (browser || browser === false) {
                var _a = browser || { maxAgeSeconds: 0 }, maxAgeSeconds = _a.maxAgeSeconds, serviceWorkerSeconds = _a.serviceWorkerSeconds;
                if (maxAgeSeconds === 0) {
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: 'private, no-store, no-cache',
                    });
                }
                else if (maxAgeSeconds) {
                    // Here we use "private" instead of "public" to prevent downstream CDNs from caching the asset
                    // Since we already have an explicit way to cache at edge, we choose to keep browser and edge
                    // caching totally separate.
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: "private, max-age=" + maxAgeSeconds,
                    });
                }
                if (serviceWorkerSeconds) {
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.xSwCacheControl,
                        value: "max-age=" + serviceWorkerSeconds,
                    });
                }
            }
        };
        /**
         * Sends string content back to client. If content is a string, the response will be sent
         * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
         * @param content The content to send to the browser
         * @param statusCode The HTTP status code
         * @param statusMessage The HTTP status message
         */
        _this.send = function (content, statusCode, statusMessage) {
            if (statusCode === void 0) { statusCode = 200; }
            if (typeof content === 'function') {
                _this.render();
            }
            else {
                _this.setEdgeRoute({
                    action: constants_1.ACTIONS.syntheticRes,
                    statusCode: statusCode,
                    statusMessage: statusMessage,
                    content: content,
                });
            }
        };
        /**
         * Computed responses are always proxied to the serverless backend.
         * @param callback
         */
        _this.compute = function (callback) {
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
        };
        /**
         * Passes request and response to the specified callback, which should
         * handle rendering the response as a string
         */
        _this.render = function () {
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
            return Promise.resolve();
        };
        _this.edgeConfig = {
            transform: {
                request: [],
                upstreamResponse: [],
                response: [],
            },
        };
        return _this;
    }
    /**
     * Sets the edge route and injects the x-xdn-route header value.
     *
     * Notes:
     * - We need `x-xdn-route` header for statistics so we log it in the edge.
     * We thus set it on the request, which allows us to log it, but in the edge
     * code we unset this header before going upstream which avoids any leaking.
     * - route.criteria.path can be null (fallback, or different match method)
     * so we check that the path exists or injecting the request path as a fallback.
     * - We don't allow upstream to dicate the `vary` header - developers can use
     * our custom cache key mechanism which is a superset anyways. The only
     * header we allow in the `vary` is `accept-encoding` which then shards
     * the cache depending on the encoding that the user agent is accepting.
     * In any case we already include `accept-encoding` in the default cache
     * key so including it in `vary` is superfluous *except* that downstream
     * caches might use it.
     *
     * @private
     */
    EdgeResponseWriter.prototype.setEdgeRoute = function (route) {
        this.edgeConfig.route = route;
        this.edgeConfig.transform.upstreamResponse.push({
            action: constants_1.ACTIONS.setHeader,
            name: constants_1.HTTP_HEADERS.vary,
            value: constants_1.HTTP_HEADERS.acceptEncoding,
        });
    };
    return EdgeResponseWriter;
}(ResponseWriter_1.default));
exports.default = EdgeResponseWriter;
