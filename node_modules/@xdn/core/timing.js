"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("./constants");
var context_1 = require("./context");
exports.NOT_ENDED_VALUE = 'na';
var InternalTiming = /** @class */ (function () {
    /**
     * @param name The name of the timing component that will be reported in the `x-xdn-user-t` header
     */
    function InternalTiming(name, internal) {
        if (internal === void 0) { internal = true; }
        /**
         * The number of milliseconds elapsed
         */
        this.duration = 0;
        /**
         * Set to true if the timing has been ended
         */
        this.ended = false;
        this.name = name;
        var timings = internal ? internalTimings() : userTimings();
        timings.push(this);
    }
    /**
     * Starts the timing.
     * @returns A self-reference, suitable for chaining
     */
    InternalTiming.prototype.start = function () {
        this.startTime = new Date();
        this.ended = false;
        return this;
    };
    /**
     * Sets the discrete value for this timing
     * @param discreteValue
     * @returns A self-reference, suitable for chaining
     */
    InternalTiming.prototype.set = function (discreteValue) {
        this.discreteValue = discreteValue;
        return this;
    };
    /**
     * Ends the timing.
     * @returns A self-reference, suitable for chaining
     */
    InternalTiming.prototype.end = function () {
        if (!this.startTime) {
            console.warn("Timing " + this.name + " not started.");
            return this;
        }
        this.ended = true;
        this.duration += new Date().getTime() - this.startTime.getTime();
        return this;
    };
    /**
     * Convenience method that is the same as `end`, but meant to indicate
     * that the timing may be resumed later
     */
    InternalTiming.prototype.pause = function () {
        return this.end();
    };
    /**
     * Convenience method that is the same as `start`, but meant to indicate
     * that the timing has been paused.
     */
    InternalTiming.prototype.resume = function () {
        return this.start();
    };
    Object.defineProperty(InternalTiming.prototype, "value", {
        /**
         * Gets the value of the timing for response headers. Will be 'na' if not started, otherwise
         * the numeric duration in milliseconds.
         */
        get: function () {
            if (this.discreteValue != null) {
                return this.discreteValue;
            }
            else {
                return this.ended ? this.duration : exports.NOT_ENDED_VALUE;
            }
        },
        enumerable: true,
        configurable: true
    });
    return InternalTiming;
}());
exports.InternalTiming = InternalTiming;
/**
 * A higher order function that wraps the provided function in a request context with user
 * and internal timings reset
 * @private
 * @param handler
 */
function withTimings(handler) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return context_1.withContext(function () {
            return handler.apply(void 0, __spread(args));
        });
    };
}
exports.withTimings = withTimings;
/**
 * Returns the value of the internal timing with the specified name
 * @private
 * @param name The name of an internal timing, for example "oc"
 */
function getInternalTiming(name) {
    var _a;
    return (_a = internalTimings().find(function (t) { return t.name === name; })) === null || _a === void 0 ? void 0 : _a.value;
}
exports.getInternalTiming = getInternalTiming;
/**
 * Returns the internal timings from the current request context
 * @private
 */
function internalTimings() {
    return context_1.get('internalTimings', []);
}
/**
 * Returns the user timings from the current request context
 * @private
 */
function userTimings() {
    return context_1.get('userTimings', []);
}
/**
 * Adds x-xdn-t, x-xdn-user-t, and server-timing headers to the response
 * @private
 * @param response
 */
function addTimings(response) {
    var userT = userTimings();
    var internalT = internalTimings();
    if (userT.length) {
        response.setHeader(constants_1.HTTP_HEADERS.xXdnUserT, getTimingsResponseHeader(userT));
        response.setHeader(constants_1.HTTP_HEADERS.serverTiming, appendServerTimings(response));
    }
    if (internalT.length) {
        response.setHeader(constants_1.HTTP_HEADERS.xXdnT, getTimingsResponseHeader(internalT));
    }
}
exports.addTimings = addTimings;
/**
 * Gets the value of the x-xdn-user-t header.
 * @private
 */
function getTimingsResponseHeader(timings) {
    return timings.map(function (t) { return t.name + "=" + t.value; }).join(',');
}
/**
 * Returns the user timings in server-timing response header format
 * @private
 */
function appendServerTimings(response) {
    var existingHeader = response.getHeader(constants_1.HTTP_HEADERS.serverTiming);
    var timings = userTimings().map(function (t) { return t.name + ";dur=" + t.value; });
    if (Array.isArray(existingHeader)) {
        timings.push.apply(timings, __spread(existingHeader));
    }
    else if (existingHeader) {
        timings.push(existingHeader);
    }
    return timings.join(', ');
}
/**
 * Allows you to track the performance of your code and asynchronous operations such as fetches.
 * Timings will be returned as a comma delimited list in the `x-xdn-user-t` header.
 *
 * ** Example **
 *
 * ```js
 * import Timing from '@xdn/core/timing'
 *
 * const timing = new Timing('fetch').start()
 * const result = await fetch('http://my-api.com/products/1')
 * timing.end() // will result in `x-xdn-user-t: fetch=(millis)` response header
 * ```
 *
 * If a timing is started but not finished by the time the response is sent, the value will be `na`.
 */
var Timing = /** @class */ (function (_super) {
    __extends(Timing, _super);
    function Timing(name) {
        return _super.call(this, name, false) || this;
    }
    return Timing;
}(InternalTiming));
exports.default = Timing;
/**
 * Names for x-xdn-t components
 */
var InternalNames;
(function (InternalNames) {
    InternalNames["edgeCache"] = "oc";
    InternalNames["transformRequest"] = "wa";
    InternalNames["transformResponse"] = "wz";
    InternalNames["routeMatching"] = "wr";
    InternalNames["proxying"] = "wp";
})(InternalNames = exports.InternalNames || (exports.InternalNames = {}));
/**
 * Values for edgeCache component of x-xdn-t
 */
var CacheValue;
(function (CacheValue) {
    CacheValue["hit"] = "hit";
    CacheValue["pass"] = "pass";
    CacheValue["cached"] = "cached";
})(CacheValue = exports.CacheValue || (exports.CacheValue = {}));
