"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_to_regexp_1 = require("path-to-regexp");
/**
 * Error class thrown by PathMatcher class.
 */
var PathMatcherError = /** @class */ (function (_super) {
    __extends(PathMatcherError, _super);
    function PathMatcherError(message) {
        var _this = _super.call(this, message) // istanbul ignore next - this is a known issue with TypeScript
         || this;
        _this.isUserError = true;
        return _this;
    }
    return PathMatcherError;
}(Error));
/**
 * @private
 * A simple abstraction of path-to-regexp that makes the process of
 * extracting variables from requests paths repeatable across multiple use cases
 * such as matching a route and rewriting params.
 */
var PathMatcher = /** @class */ (function () {
    /**
     * A path patam in path-to-regexp syntax
     * @param pattern
     */
    function PathMatcher(pattern) {
        this.pattern = pattern;
    }
    /**
     * Returns key/value pairs if the path matches the pattern, otherwise undefined
     * @param path
     */
    PathMatcher.prototype.match = function (path) {
        if (!this.matcher) {
            try {
                this.matcher = path_to_regexp_1.match(this.pattern, { decode: decodeURIComponent });
            }
            catch (e) {
                throw new PathMatcherError("Route pattern \"" + this.pattern + "\" contains invalid syntax.");
            }
        }
        PathMatcher.validatePattern(this.pattern);
        var result = this.matcher(path);
        return result ? result.params : undefined;
    };
    /**
     * Validate the given pattern as acceptable. If it's not acceptable an exception is raised
     * with sufficient information to fix the problem.
     *
     * Notes:
     * - Partial splat patterns (e.g. `/partial-:splat*`) have both semantic and execution issues.
     * Semantic issues lie in the fact that path-to-regexp will generate a surprisingly different
     * regexp for partial splat vs full splat pattern (e.g. `/full/:splat*`) that will actually not
     * match all the sub-paths that follow the partial prefix but rather only the rest of the path
     * until the end of the string. Execution issues lie in the fact that such regexes have been
     * observed to block Chrome, Node and other regular expression engines. To prevent issues with
     * these patterns we do not support them but propose a reasonable alternative of splitting the
     * splat into fixed and splat parameters.
     */
    PathMatcher.validatePattern = function (pattern) {
        var partialSplatRouteMatch = pattern.match(this.PARTIAL_SPLAT_ROUTE);
        if (partialSplatRouteMatch) {
            var _a = __read(partialSplatRouteMatch, 3), _1 = _a[0], prefix = _a[1], splat = _a[2];
            var alternativePattern = pattern.replace("" + prefix + splat, prefix + ":suffix/" + splat);
            throw new PathMatcherError("Partial splat routes are not supported. Use \"" + alternativePattern + "\" instead of \"" + pattern + "\"");
        }
        return true;
    };
    /**
     * Matches partial splat (e.g. `/partial-:splat*`) routes.
     */
    PathMatcher.PARTIAL_SPLAT_ROUTE = /(\/[^:/]+)(:[^*/#?]+\*)/;
    return PathMatcher;
}());
exports.default = PathMatcher;
