"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapValues_1 = __importDefault(require("lodash/mapValues"));
var fromPairs_1 = __importDefault(require("lodash/fromPairs"));
var universalRouteUtils_1 = require("./universalRouteUtils");
/**
 * A serializable array of route descriptors to be passed to the browser.
 * @private
 */
var CacheManifest = /** @class */ (function () {
    function CacheManifest(entries) {
        this.entries = entries || [];
    }
    Object.defineProperty(CacheManifest.prototype, "cacheableEntries", {
        /**
         * Returns a list of entries in this CacheManifest where both the browser and
         * edge cache times are defined, and greater than 0
         */
        get: function () {
            return this.entries.filter(CacheManifest.isEntryCacheable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CacheManifest.prototype, "spaRoutes", {
        /**
         * Returns a list of routes (as RegExp) that are cacheable SPA routes
         */
        get: function () {
            return this.cacheableEntries
                .filter(function (_a) {
                var cacheOptions = _a.cacheOptions;
                return cacheOptions.browser && cacheOptions.browser.spa;
            })
                .map(function (_a) {
                var route = _a.route;
                return new RegExp(route, 'i');
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if the URL should be prefetched, based on the matched route's `cacheOptions`
     * @param {URL} url The URL to test
     */
    CacheManifest.prototype.shouldPrefetch = function (url) {
        var doPrefetch = false;
        this.entries.some(function (entry) {
            var matches = CacheManifest.entryMatches(entry, url);
            if (matches) {
                doPrefetch =
                    CacheManifest.isEntryCacheable(entry) || !!entry.cacheOptions.prefetchUpstreamRequests;
                // if it's prefetchable, or if it matches a stop route, then no need to continue checking:
                return doPrefetch || entry.returnsResponse;
            }
            return false;
        });
        return doPrefetch;
    };
    /**
     * Returns true if the entry matches the URL's path, query params, and/or protocol
     * @param {CacheManifestEntry} entry The entry to test
     * @param {URL} url URL to check against the entry
     */
    CacheManifest.entryMatches = function (entry, url) {
        return (new RegExp(entry.route, 'i').test(url.pathname) &&
            universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(mapValues_1.default(entry.query || {}, function (value) { return (value ? new RegExp(value, 'i') : null); }), fromPairs_1.default(Array.from(url.searchParams.entries()))) &&
            (entry.protocol ? new RegExp(entry.protocol, 'i').test(url.protocol) : true));
    };
    /**
     * Returns true if the given entry has its `cacheOptions` set so that the route
     * is cacheable by the edge and the browser.
     * @param {CacheManifestEntry} entry The entry to test
     */
    CacheManifest.isEntryCacheable = function (_a) {
        var cacheOptions = _a.cacheOptions;
        return !!(cacheOptions.browser &&
            (cacheOptions.browser.serviceWorkerSeconds || 0) > 0 &&
            cacheOptions.edge &&
            (cacheOptions.edge.maxAgeSeconds || 0) > 0);
    };
    /**
     * Creates a new `CacheManifest` object from the provided serialized entries
     */
    CacheManifest.fromEntries = function (entries) {
        return new CacheManifest(entries);
    };
    /**
     * Serializes the list so that it can be passed to the browser
     */
    CacheManifest.prototype.toJSON = function () {
        return JSON.stringify(this.entries);
    };
    return CacheManifest;
}());
exports.default = CacheManifest;
