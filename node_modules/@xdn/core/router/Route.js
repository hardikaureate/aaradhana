"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cookie_1 = require("cookie");
var path_to_regexp_1 = require("path-to-regexp");
var toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
var every_1 = __importDefault(require("lodash/every"));
var toLower_1 = __importDefault(require("lodash/toLower"));
var PathMatcher_1 = __importDefault(require("./PathMatcher"));
var normalizeCriteria_1 = __importDefault(require("./normalizeCriteria"));
var constants_1 = require("../constants");
var querystring_1 = __importDefault(require("querystring"));
var universalRouteUtils_1 = require("./universalRouteUtils");
/**
 * @private
 */
var Route = /** @class */ (function () {
    /**
     * Creates a new Route
     * @param criteria A string or an object with `path`, `headers`, and `method`.
     * @param handler A route handler
     */
    function Route(criteria, handler) {
        this.criteria = normalizeCriteria_1.default(criteria);
        this.handler = handler;
        if (this.criteria.path) {
            this.matcher = new PathMatcher_1.default(this.criteria.path);
        }
    }
    /**
     * Returns params if route matches the request's method, headers, cookies and path.
     * @param req
     * @return The path params if the route matches the current request, otherwise false
     */
    Route.prototype.match = function (req) {
        var e_1, _a;
        // Params are mostly extracted from path, but in they can also be extracted from query string, header, cookie, etc.
        // although that would need to be implemented at EDGE too, which in general is not trivial.
        // As of now, on EDGE, this is only implemented for query string params to inject in redirect()
        var matchParamsFns = [
            this.matchPath,
            this.matchProtocol,
            this.matchMethod,
            this.matchHeaders,
            this.matchQueryParams,
            this.matchCookies,
        ];
        var mergedParams = {};
        try {
            for (var matchParamsFns_1 = __values(matchParamsFns), matchParamsFns_1_1 = matchParamsFns_1.next(); !matchParamsFns_1_1.done; matchParamsFns_1_1 = matchParamsFns_1.next()) {
                var matchParamsFn = matchParamsFns_1_1.value;
                var paramsOrBoolean = matchParamsFn.bind(this)(req);
                if (!paramsOrBoolean) {
                    // One matcher failed, no need to go further
                    return false;
                }
                Object.assign(mergedParams, paramsOrBoolean);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (matchParamsFns_1_1 && !matchParamsFns_1_1.done && (_a = matchParamsFns_1.return)) _a.call(matchParamsFns_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // We wait until now before assigning params to the request so we are sure the route actually matched the request.
        req.params = mergedParams;
        return mergedParams;
    };
    // Match criteria path to request url
    Route.prototype.matchPath = function (req) {
        if (this.matcher) {
            return this.matcher.match(req.path);
        }
        else {
            return {}; // return a match with no params
        }
    };
    // Match criteria method to request method
    Route.prototype.matchMethod = function (req) {
        if (!this.criteria.method || !req.method) {
            return true;
        }
        return new RegExp(this.criteria.method, 'i').test(req.method);
    };
    /**
     * Run thru criteria headers and match with request headers.
     *
     * Header names are *not* case-sensitive and they are all lower-cased per Node behavior we pass `toLower` to matcher function.
     *
     * @param req Request object
     */
    Route.prototype.matchHeaders = function (req) {
        if (this.criteria.headers) {
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.headers, req.headers, toLower_1.default);
        }
        return true;
    };
    /**
     * Run thru criteria query and match with request query parameters.
     *
     * Query string names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    Route.prototype.matchQueryParams = function (req) {
        if (this.criteria.query) {
            // When there's no query params it means there's no way it's a match when criteria is set
            if (!req.query) {
                return false;
            }
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.query, req.query);
        }
        return true;
    };
    /**
     * Run thru criteria cookies and match with request cookies.
     *
     * Cookie names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    Route.prototype.matchCookies = function (req) {
        if (this.criteria.cookies) {
            var cookieHeader = req.headers['cookie'];
            if (cookieHeader == null) {
                // When there is no cookie header, we return true only if all matchers
                // on cookies are null meaning "cookie not present".
                return every_1.default(this.criteria.cookies, function (regex) { return regex === null; });
            }
            var cookieValue = Array.isArray(cookieHeader) ? cookieHeader.join('; ') : cookieHeader;
            var reqCookies = cookie_1.parse(cookieValue);
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.cookies, reqCookies);
        }
        return true;
    };
    /**
     * Match the protocol for the request. All routes have the implicit `https` protocol
     * unless explicitly specified as something else.
     *
     * Because HTTP is a subset of HTTPS we make sure that when strings are used we match
     * the whole value rather than just a part of it.
     *
     * @param req Request object
     */
    Route.prototype.matchProtocol = function (req) {
        var protocol = (req.headers && req.headers[constants_1.HTTP_HEADERS.xXdnProtocol]) || 'https';
        var criteriaProtocolRegex;
        if (typeof this.criteria.protocol === 'string') {
            criteriaProtocolRegex = new RegExp("^" + this.criteria.protocol + "$", 'i');
        }
        else {
            criteriaProtocolRegex = new RegExp(this.criteria.protocol || '^https$', 'i');
        }
        return universalRouteUtils_1.testRegExp(criteriaProtocolRegex, protocol);
    };
    Route.prototype.toString = function () {
        var _a = this.criteria, path = _a.path, criteria = __rest(_a, ["path"]);
        if (Object.keys(criteria).length) {
            return JSON.stringify(this.criteria);
        }
        else if (path) {
            return path;
        }
        else {
            return 'fallback';
        }
    };
    Route.prototype.toRegex = function () {
        return Route.toRegexp(this.criteria.path);
    };
    /**
     * Returns criteria json
     * This is consumed by cache metrics that will transform the route to be as similar as in routes file
     */
    Route.prototype.toJson = function () {
        return JSON.stringify(this.criteria, function (key, value) {
            // We have to convert regular expressions to string otherwise it will not be logged
            if (value instanceof RegExp) {
                return value.toString();
            }
            return value;
        });
    };
    /**
     * Returns a string with the regex representation of the route.
     * @returns Regexp string representation of the route
     */
    Route.prototype.toRegexString = function () {
        return this.toRegex().source;
    };
    /**
     * Returns a regex string compatible with the edge regular express parser
     */
    Route.prototype.toEdgeRegexString = function () {
        return Route.toEdgeRegexString(this.criteria.path);
    };
    Route.toRegexp = function (path) {
        if (path) {
            return path_to_regexp_1.pathToRegexp(path);
        }
        else {
            // For fallbacks we want everything matched so that we can replace everything if needed.
            // We insist on total matching with `^` and `$` because some regex replacement algorithms
            // have issues with correctly applying `.*` in completely greedy manner (e.g. Fastly's `regsuball`)
            return /^.*$/;
        }
    };
    Route.toEdgeRegexString = function (path) {
        return toEdgeRegex_1.default(Route.toRegexp(path));
    };
    /**
     * Generate a path-to-regexp comptible path that includes query strings
     * In path-to-regexp, '?' is a special character so it needs to be escaped
     *
     * Note that we prevent querystring from escaping ':', which is used to inject
     * matched params from the path
     *
     * @param path
     * @param query
     */
    Route.pathWithQueryString = function (path, query) {
        var queryString = querystring_1.default.stringify(query).replace(/%3A/g, ':');
        return path + (queryString && "\\?" + queryString);
    };
    return Route;
}());
exports.default = Route;
