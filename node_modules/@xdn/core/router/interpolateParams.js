"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cookie_1 = __importDefault(require("cookie"));
var querystring_1 = require("querystring");
var identity_1 = __importDefault(require("lodash/identity"));
/**
 * @private
 * Emulates the edge by interpolating header values
 *
 * Note: This code must be kept in sync with the interpolateParams: value from
 *       xdn/packages/build-lambda/src/outer-edge/fastly/vcl-generator/vcl-generator.js
 *
 * Supported interpolation strings are:
 *  - ${method}: the request method GET/PUT/POST/etc...
 *  - ${path}: the return path without query parameters
 *  - ${url}: the original unmodified request url
 *  - ${req:<request header name>}: a request header value
 *  - ${req:cookie:<request cookie name>}: a request cookie value
 *  - ${res:<response header name>}: a response header value
 *
 * @param req The request
 * @param res The response
 * @param value The string or array of strings to interpolate
 */
function interpolateParams(req, res, value) {
    if (typeof value === 'string') {
        return interpolateParam(req, res, value);
    }
    if (!Array.isArray(value)) {
        // Skip any non-string and non-string array values
        return value;
    }
    var results = [];
    value.forEach(function (v) {
        results.push(interpolateParams(req, res, v));
    });
    return results;
}
exports.default = interpolateParams;
/**
 * @private
 * Interpolates a single string value
 *
 *  NOTE: We emulate the Fastly Edge closely, but there are known difference. E.g. if you have header='hi ${req:cookie:test}' and there is no
 *        cookie name 'test' Fastly will return header='hi (null)' but if you have header='${req:cookie:test}' Fastly will drop the header.
 *        This interpolator just returns '' for not found values.
 * @param req The request
 * @param res The response
 * @param value a string to interpolate
 */
function interpolateParam(req, res, value) {
    // We can have multiple replacements per value, so we need to loop through all the possible cases
    // Use '--backslashdollar--' so we do not interpret '\${' in the results.
    // Use '--separator--' so we keep the '${' in the results of split().
    var segments = value
        .replace(/\\\${/g, '--backslashdollar--')
        .replace(/\${/g, '--separator--${')
        .split('--separator--');
    // Parse cookies once at the top of the function as an optimization
    var cookies = {};
    if (req === null || req === void 0 ? void 0 : req.headers.cookie) {
        // Pass in the 'do nothing' decode function to return the cookie value without decoding it
        cookies = cookie_1.default.parse(req.headers.cookie, { decode: identity_1.default });
    }
    // Parse query parameters once at the top of the function as an optimization
    var qs = {};
    if (req === null || req === void 0 ? void 0 : req.url) {
        var queryParameterIndex = req.url.indexOf('?');
        if (queryParameterIndex >= 0) {
            var queryParameters = req.url.substring(queryParameterIndex + 1);
            qs = querystring_1.parse(queryParameters);
        }
    }
    var interpolatedResults = [];
    var requestPrefixLength = '${req:'.length;
    var queryPrefixLength = '${query:'.length;
    segments.forEach(function (segment) {
        if (req) {
            segment = segment.replace(/\${method}/, req.method);
            segment = segment.replace(/\${path}/, req.path);
            segment = segment.replace(/\${url}/, req.url);
            // ${query:paramName} returns the found query parameter
            var startQueryParameterIndex = segment.search(/\${query:/);
            if (startQueryParameterIndex >= 0) {
                var queryParameterName = segment.substring(startQueryParameterIndex + queryPrefixLength);
                var endQueryParameterIndex = queryParameterName.indexOf('}');
                if (endQueryParameterIndex <= 0) {
                    throw new Error("Cannot interpolate substring \"" + segment + "\" of value \"" + value + "\" (1)");
                }
                queryParameterName = queryParameterName.substring(0, endQueryParameterIndex);
                // When there are multiple matches for the query parameter's name, we emulate
                // the edge's behavior and return the first match only.
                var queryReplacementString = qs[queryParameterName] || '';
                if (Array.isArray(queryReplacementString)) {
                    queryReplacementString = queryReplacementString[0];
                }
                segment = segment.replace(/\${query:.*?}/, queryReplacementString);
            }
            var startRequestIndex = segment.search(/\${req:/);
            if (startRequestIndex >= 0) {
                var requestHeaderName = segment.substring(startRequestIndex + requestPrefixLength);
                var endRequestIndex = requestHeaderName.indexOf('}');
                if (endRequestIndex <= 0) {
                    throw new Error("Cannot interpolate substring \"" + segment + "\" of value \"" + value + "\" (2)");
                }
                requestHeaderName = requestHeaderName.substring(0, endRequestIndex);
                // req:cookie:<key> injects the value of cookie named <key> or an empty string if <key> not found
                var replacementString = '';
                if (requestHeaderName.indexOf('cookie:') === 0) {
                    var cookieName = requestHeaderName.split(':')[1];
                    replacementString = cookies[cookieName] || '';
                }
                else {
                    // Use an empty string if the request header is not found
                    replacementString = req.headers[requestHeaderName] || '';
                }
                segment = segment.replace(/\${req:.*?}/, replacementString);
            }
        }
        var startResponseIndex = segment.search(/\${res:/);
        if (startResponseIndex >= 0) {
            if (!res) {
                throw new Error("Cannot interpolate response parameter \"" + segment + "\" during receive phase");
            }
            var responseHeaderName = segment.substring(startResponseIndex + requestPrefixLength);
            var endResponseIndex = responseHeaderName.indexOf('}');
            if (endResponseIndex <= 0) {
                throw new Error("Cannot interpolate substring \"" + segment + "\" of value \"" + value + "\" (3)");
            }
            responseHeaderName = responseHeaderName.substring(0, endResponseIndex);
            segment = segment.replace(/\${res:.*?}/, res.getHeader(responseHeaderName) || '');
        }
        // If no replacement was done, we assume the <key> in ${<key>} was not valid and throw an error
        if (segment.search(/\${/) >= 0) {
            throw new Error("Cannot interpolate substring \"" + segment + "\" of \"" + value + "\" (4)");
        }
        interpolatedResults.push(segment);
    });
    return interpolatedResults.join('').replace(/--backslashdollar--/g, '${');
}
