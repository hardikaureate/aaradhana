"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("../constants");
var crypto_1 = __importDefault(require("crypto"));
/**
 * An actual cache key derived from a request per the user's CustomCacheKey specification
 */
var CacheKey = /** @class */ (function () {
    function CacheKey(request, customKey) {
        var e_1, _a;
        var _b;
        this.cookies = {};
        var host = request.headers.host;
        this.body = request.body;
        this.method = (_b = request.method) === null || _b === void 0 ? void 0 : _b.toLowerCase();
        this.query = this.excludeXDNQueryParams(request.query || {});
        this.pathname = new URL(request.url, "http://" + host).pathname;
        this.headers = this.getDefaultHeaders(request.headers);
        if (customKey) {
            try {
                for (var _c = __values(customKey.getActions()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var action = _d.value;
                    action(this, request);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    CacheKey.create = function (request, customKey) {
        return new CacheKey(request, customKey);
    };
    /**
     * We always ignore xdn_* query params when computing the cache key so that things like xdn_prefetch don't cache bust
     * @param query
     */
    CacheKey.prototype.excludeXDNQueryParams = function (query) {
        var result = {};
        for (var name_1 in query) {
            if (!name_1.startsWith('xdn_')) {
                result[name_1] = query[name_1];
            }
        }
        return result;
    };
    /**
     * Returns an array of values in the object sorted by the key
     * We sort query params so that different orderings will result in a hit
     * @param source Any object of key/value pairs, e.g. query, headers, cookies, etc...
     */
    CacheKey.prototype.toSortedArray = function (source) {
        return Object.keys(source)
            .sort()
            .map(function (key) { return [key, source[key]]; });
    };
    /**
     * Returns the values of the request headers that are by default included in the caching key
     *
     * Notes:
     * - Cache hash calculation has a connascence of algorithm with VCL moov_hash subroutine so if you
     * are modifying it in any way, you have to modify VCL code generator in the same way. When in doubt
     * the VCL cache hash calculation takes precendence as it is designed to serve production traffic
     * and has been battle tested to do so reliably.
     * - VCL cache hash includes some request/service properties that do no apply in local development:
     * * build number does not exist for local development
     * * flush timestamps for gradual flushing do not apply locally
     */
    CacheKey.prototype.getDefaultHeaders = function (headers) {
        var _a;
        return _a = {},
            _a[constants_1.HTTP_HEADERS.host] = headers[constants_1.HTTP_HEADERS.host],
            _a[constants_1.HTTP_HEADERS.acceptEncoding] = headers[constants_1.HTTP_HEADERS.acceptEncoding],
            _a[constants_1.HTTP_HEADERS.xXdnDestination] = headers[constants_1.HTTP_HEADERS.xXdnDestination],
            _a[constants_1.HTTP_HEADERS.xXdnProtocol] = headers[constants_1.HTTP_HEADERS.xXdnProtocol],
            _a;
    };
    CacheKey.prototype.toString = function () {
        return JSON.stringify({
            pathname: this.pathname,
            method: this.method,
            query: this.toSortedArray(this.query),
            body: hash(this.body),
            headers: this.toSortedArray(this.headers),
            cookies: this.toSortedArray(this.cookies),
        });
    };
    return CacheKey;
}());
exports.default = CacheKey;
/**
 * Returns the sha256 hash of the provided string as hex
 * @param data The data to hash
 */
function hash(data) {
    if (!data)
        return null;
    var hash = crypto_1.default.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
}
