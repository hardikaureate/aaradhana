"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const fse = require('fs-extra');

const {
  compact,
  get,
  isEmpty
} = require('lodash');

const {
  EOL
} = require('os');

const sleep = require('../utils/sleep');

const packageProject = require('../utils/packageProject');

const git = require('../utils/git');

const XdnPackageJson = require('../utils/XdnPackageJson');

const getCoreXdnVersion = require('../utils/getCoreXdnVersion');

const buildProject = require('../utils/build');

const {
  readXdnVersion,
  ensureDomainServedByXdnBuild
} = require('../utils/xdn');

const authenticate = require('../prompts/authenticate');

const detectFramework = require('../frameworks/detectFramework');

const {
  DeployError,
  ValidationError,
  XdnCLIError,
  XdnBuildError
} = require('../utils/errors');

const stdStreamsObserver = require('../utils/stdStreamsObserver');

const announceSuccessfulDeployment = require('../utils/announceSuccessfulDeployment');

const announceFailedDeployment = require('../utils/announceFailedDeployment');

const buildCommand = require('./build');

exports.command = 'deploy [team]';
exports.describe = 'Deploys your project to the Moovweb XDN';
exports.builder = _objectSpread({}, buildCommand.builder, {
  skipFramework: _objectSpread({}, buildCommand.builder.skipFramework, {
    alias: 'sf'
  }),
  site: {
    type: 'string',
    alias: 's',
    describe: 'Slug of the site to deploy to, using package.json name property by default.'
  },
  'skip-build': {
    type: 'boolean',
    describe: 'Skips rebuilding your app and deploys the previous build instead.'
  },
  path: {
    type: 'string',
    describe: "Path to your site's root directory. Uses current directory by default.",
    default: '.'
  },
  team: {
    type: 'string',
    alias: 't',
    describe: 'The name of the team under which the site will be deployed. The site will be deployed to your private space if omitted.'
  },
  branch: {
    type: 'string',
    alias: 'b',
    describe: 'The name of the source control branch. This is automatically set when using Git.'
  },
  environment: {
    type: 'string',
    alias: 'e',
    describe: 'Environment to deploy to. Uses default environment if omitted.'
  },
  'commit-url': {
    type: 'string',
    describe: `Custom commit url. Automatically works for github, bitbucket and gitlab. Git SHA is appended at the end of the provided url.${EOL}` + 'Example: https://github.com/jlord/sheetsee.js/commit/'
  },
  'wait-xdn': {
    type: 'boolean',
    describe: 'Flag indicating if build of your app should wait for it to be distributed to the nearest global XDN POP.',
    default: true
  }
}); // Per https://nodejs.org/api/process.html#process_signal_events we chose
// the following signals to be handled:

const HANDLED_PROCESS_SIGNAL_EVENTS = ['SIGTERM', 'SIGINT', 'SIGHUP', 'SIGBREAK'];

class DeployCommand {
  constructor(yargs) {
    _defineProperty(this, "run", async () => {
      const {
        context
      } = this._yargs;
      this._context = context; // Register all the signal events for handling before starting the run.

      this._registerProcessSignalHandlers();

      try {
        await this._wrappedRun();
      } catch (e) {
        await this._failBuild(context, e);
        throw e;
      } finally {
        this._deregisterProcessSignalHandlers();
      }
    });

    _defineProperty(this, "_wrappedRun", async () => {
      const {
        context,
        path: givenPath,
        team: teamSlug,
        site,
        branch,
        environment,
        skipBuild,
        commitUrl: customCommitUrl,
        waitXdn
      } = this._yargs;
      const {
        logger,
        isLocalDev
      } = context;
      const framework = await detectFramework();
      context.setLoginAction('deploy');
      await authenticate(context);
      const absolutePath = path.resolve(process.cwd(), givenPath); // Check that package.json is existing or fail the deployment

      const packageJson = XdnPackageJson.loadPackageJson(givenPath);
      const buildXdnVersion = getCoreXdnVersion();

      if (isEmpty(buildXdnVersion)) {
        throw new DeployError('@xdn/core module has not been installed, please run "xdn init".');
      } // If --site is provided override default $npm_package_name


      const siteSlug = site || packageJson.name;
      const branchName = branch || (await git.currentBranch(absolutePath));
      const isDirtyCommit = await git.isDirty();

      if (isDirtyCommit) {
        logger.warn(`You have uncommitted changes. No commit URL will be stored in moovweb.app.${EOL}`);
      }

      const commitUrl = isDirtyCommit ? undefined : await git.commitUrl(absolutePath, customCommitUrl);
      logger.title('📋 Deploying to:');
      logger.info([`> team=${teamSlug || 'Private space'}`, `> site=${siteSlug}`, branchName && `> branch=${branchName}`, `> environment=${environment || 'default'}`, `> xdn-version=${buildXdnVersion}`, commitUrl && `> commit-url=${commitUrl}`].filter(Boolean) // Removes falsy values
      .join(EOL));
      let isFirstBuild = false;
      let {
        build,
        s3SelfSignedProjectPost,
        displayedLogsCount
      } = await logger.step('⌛ Initializing...', async () => {
        const {
          build: {
            id: buildId,
            consoleUrl,
            number: buildNumber,
            environment: {
              initialized: environmentIsInitialized,
              name: environmentName
            }
          },
          s3SelfSignedProjectPost,
          deprecationWarning,
          environmentVariables
        } = await context.api.createBuild({
          siteSlug,
          teamSlug,
          environment,
          xdnVersion: buildXdnVersion,
          branch: branchName,
          framework: get(framework, 'key'),
          commitUrl
        }); // Capture the build ID immediately so that we can fail the build on any errors.

        this._buildId = buildId; // Capture the build consoleUrl so that we can log it out in case of failure.

        this._buildUrl = consoleUrl;
        logger.info(`> Deployment #${buildNumber}`); // copy environment variables from console into process.env so code can access them at build time

        for (let {
          key,
          value
        } of environmentVariables) {
          if (value != null) {
            process.env[key] = value;
          }
        }

        if (deprecationWarning) {
          logger.warn(deprecationWarning);
        }

        isFirstBuild = !environmentIsInitialized;

        if (isFirstBuild) {
          logger.warn(`> Since this is the first deployment to the ${environmentName} environment, it will take longer than subsequent deployments.`);
        }

        const {
          build,
          displayedLogsCount
        } = await this._streamLogsUntilStatus(context, ['failed', 'initialized', 'uploading']);
        return {
          build,
          s3SelfSignedProjectPost,
          displayedLogsCount
        };
      });

      if (build.status === 'failed') {
        throw new XdnBuildError(build);
      }

      if (!skipBuild) {
        const streamsObserver = stdStreamsObserver([process.stdout, process.stderr]);

        try {
          await buildProject(this._yargs);
        } catch (e) {
          if (e.type === 'FrameworkBuildError') {
            throw new DeployError(e.message, {
              addToLeDeployerLogs: streamsObserver.getOutput()
            });
          } else {
            throw new DeployError('Project build failed', {
              errorDetails: e.stack || e.message,
              addToLeDeployerLogs: streamsObserver.getOutput()
            });
          }
        } finally {
          streamsObserver.detach();
        }
      } // Check that the XDN versions match unless we are overriding the versions for platform development.


      if (isEmpty(process.env.XDN_VERSION_OVERRIDE)) {
        const builtXdnVersion = await readXdnVersion(absolutePath);

        if (buildXdnVersion !== builtXdnVersion) {
          throw new DeployError(`Please rebuild with XDN v${buildXdnVersion}`);
        }
      } // Puts projectRoot/.xdn folder into zip


      const projectZipFile = await packageProject(absolutePath, this._yargs);
      await logger.step('📡️ Uploading...', async () => {
        logger.info('> Uploading package');
        const zipFileStream = fse.createReadStream(projectZipFile);
        await context.api.presignedUploadToS3(s3SelfSignedProjectPost, zipFileStream);
        await context.api.updateBuild(this._buildId, {
          status: 'uploaded'
        });
        await fse.remove(projectZipFile);
      });
      build = await logger.step('⌛ Deploying...', async () => {
        // Now that we have finished with uploading and we are just waiting we should
        // not fail the builds if CLI fails or is interrupted.
        this._deregisterProcessSignalHandlers();

        const {
          build
        } = await this._streamLogsUntilStatus(context, ['failed', 'completed'], displayedLogsCount);

        if (build.status === 'failed') {
          return build;
        } // In local development, we usually mock the edge deployment
        // so this will never respond


        if ((isFirstBuild || waitXdn) && !isLocalDev) {
          logger.warn(`> Verifying that the deployment has reached your nearest global POP...`);
          const ARBITRARY_SERVED_TIMEOUT_MS = 5 * 60 * 1000;
          const served = await ensureDomainServedByXdnBuild(logger, build.environment.dnsDomainName, build.number, ARBITRARY_SERVED_TIMEOUT_MS);

          if (!served) {
            logger.warn('> Build has not yet propagated. If the problem persists please contact support@moovweb.com');
          }
        }

        return build;
      });

      if (build.status === 'completed') {
        logger.info(EOL + announceSuccessfulDeployment(build.consoleUrl, build.environment.url) + EOL);
      } else if (build.status === 'failed') {
        throw new XdnBuildError(build);
      }
    });

    _defineProperty(this, "_streamLogsUntilStatus", async (context, statuses, displayedLogsCount = 0) => {
      const {
        logger
      } = context; // TODO: use subscriptions?

      const LOG_PULL_DELAY = 5000;
      let build;

      while (!build || !statuses.includes(build.status)) {
        await sleep(LOG_PULL_DELAY);
        build = await context.api.getBuild(this._buildId);
        const logs = compact(build.logs.split('\n'));
        const newLogs = logs.slice(displayedLogsCount);
        newLogs.forEach(newLog => logger.debug(newLog));
        displayedLogsCount = logs.length;
      }

      return {
        build,
        displayedLogsCount
      };
    });

    this._yargs = yargs;
    this._buildId = null;
    this._buildUrl = null;
  }
  /**
   * Performs the deploy command. It correctly fails the build (if it has been started)
   * on any error.
   */


  /**
   * Handler for all the process signal that we handle during the process.
   *
   * @param {String} signal ID of the signal that was raised
   */
  _processSignalHandler(signal) {
    this._failBuild(this._context, new XdnCLIError(`${signal} raised`));
  }
  /**
   * Registers process signal handlers.
   *
   * Notes:
   * - Deregistering requires the exact same binding as registering
   * as process.on doesn't return a handler that we could use.
   * This is why all the handlers are exactly the same.
   */


  _registerProcessSignalHandlers() {
    HANDLED_PROCESS_SIGNAL_EVENTS.forEach(signal => {
      process.on(signal, this._processSignalHandler.bind(this));
    });
  }
  /**
   * Deregisters process signal handlers.
   *
   * Notes:
   * - The deregistering is idempotent and we call it from multiple places.
   */


  _deregisterProcessSignalHandlers() {
    HANDLED_PROCESS_SIGNAL_EVENTS.forEach(signal => {
      process.off(signal, this._processSignalHandler.bind(this));
    });
  }

  async _failXdnBuild(context, e) {
    // XdnBuildError are already originating from a failed build on XDN so we don't need
    // to push that information back to LeDeployer. It would also result in duplicated logs
    if (e instanceof XdnBuildError) {
      return;
    }

    try {
      let message = 'Build failed';
      message += ` with error: ${e.message}`;

      if (e.errorDetails) {
        message += `\n${e.errorDetails}`;
      }

      if (e.addToLeDeployerLogs) {
        message += `\n${e.addToLeDeployerLogs}`;
      }

      if (e.stack && !e.isUserError) {
        // An error that occurred in the normal user workflow:
        // (failed sign-in, team slug not found, javascript build failure, etc...)
        // in which case we don't want to display a stack trace but just a specific error message and details
        message += e.stack;
      }

      await context.api.updateBuild(this._buildId, {
        status: 'failed'
      }, message);
    } catch (e) {
      console.error(`Update build failed: ${e.message}`);
    }
  }

  async _failBuild(context, e) {
    if (!this._buildId) {
      return;
    }

    await this._failXdnBuild(context, e);

    if (this._buildUrl) {
      context.logger.info(EOL + announceFailedDeployment(this._buildUrl) + EOL);
    }
  }

}

const validate = yargs => {
  const commitUrl = yargs.commitUrl;

  if (commitUrl && !/(http|https):\/\//.test(commitUrl)) {
    throw new ValidationError('Invalid commit url protocol');
  }
};

exports.handler = async yargs => {
  validate(yargs);
  const command = new DeployCommand(yargs);
  await command.run();
};